# 問題概要

## 難易度

Normal

## 問題内容

1車線の道路を同じ目的地に向かうn台の車が走っています。目的地はtargetマイル先です。

整数配列positionとspeed、それぞれの長さはnで、position[i]はi番目の車の位置、speed[i]はi番目の車の速度（時速マイル単位）です。

ある車が前にいる別の車を追い越すことはできませんが、追いついて同じ速度でバンパー・トゥ・バンパー（車と車の間の距離が非常に短い状態）で走ることはできます。速い車は遅い車の速度に合わせて速度を落とします。これら2台の車の間の距離は無視されます（つまり、同じ位置にあるとみなされます）。

車の隊列（fleet）とは、同じ位置と同じ速度で走っている車の非空集合です。1台の車もまた車の隊列です。

もし車が目的地でちょうど車の隊列に追いついた場合、それも1つの車の隊列とみなされます。

目的地に到着する車の隊列の数を返してください。

## 考えたこと

シンプルなケース

1. positionで降順ソートしつつデータを整形する。
2. 先頭にいる車が目的地に着くまでの時間を計算する。
3. 先頭が到着するまでに後続が追いつくかをループして調べる。
4. 追いつかない車がいたらそれを先頭扱いにして再度同じ調査をする。

効率化するケース

1. positionで降順ソートしつつデータを整形する。
2. 到着するまでに必要な時間を計算してスタックに積む
3. 1個前の値(到着必要時間)と比較して短ければ積んだスタックをポップ＝遅い車の速度に合わせる
4. 2と3の処理を繰り返し、最終的なスタックの長さが車の隊列の数

## 感想

Runtime: 24ms / Memory: 4.46MB

ロジック自体はあっているが知識が不足していた部分と実装ミス部分あり

* タプルのベクターのソート方法がわかっていなかったので調べた

以下のようなカスタムの比較関数を使用すれば良い

```rust
sorted_position.sort_by(|a, b| b.0.cmp(&a.0));
```

* i32同士の演算で余りが切り捨てられることを無視しておりWA

内部的にはスタック自体をVec<f64>で定義して、計算を行うべきだった。

