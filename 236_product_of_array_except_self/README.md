# 問題概要

## 難易度

Medium

## 問題内容

与えられた整数配列 nums に対して、answer[i] が nums[i] を除く nums の全要素の積に等しいような配列 answer を返す必要があります。
nums の任意の接頭辞または接尾辞の積は、32ビット整数に収まることが保証されています。
除算操作を使用せず、O(n)の時間で実行するアルゴリズムを記述する必要があります。

## 考えたこと

パッと思いついたのは全部かけたあとにnums[i]で割っていく処理だったが、除算操作を使用せずとのことなのでNG

例えば、n=4で考えた場合

```
nums = [1, 2, 3, 4]
ans  = [24, 12, 8, 6]
```

となり、

```
ans[0]の答えは自分より右側の積(i=2,3,4)
ans[1]の答えは自分より左側の積と右側の積(i=1,3,4)
ans[2]の答えは自分より左側の積と右側の積(i=1,2,4)
ans[3]の答えは自分より左側の積(i=1,2,3)
```
なので、左から計算していった結果と右から計算していった結果を元に

```
result[i] = left[i] * right[n-1-i]
```

となるはず

## 感想

考え方通りの計算でAccepted
Runtime 10ms/ Memory 3.3MB

Memoryが`Beats 8.50%of users with Rust`なのでメモリ効率が良い方法がありそうだったので修正を実施


当初はleftとrightとanswerと3つのベクタを生成していたが、answerだけに変更して逐次計算をするように

Runtime 6ms/ Memory 3.2MB